#include <string>

#include "k_csdk.h"
#include "textGUI.h"
#include "console.h"
#include "main.h"
using namespace std;
const int xwaspy_shift=33; // must be between 32 and 63, reflect in xcas.js and History.cc

string filename_script(const char * filename){
  string f(filename);
  if (f.size()>7)
    f=f.substr(0,7);
  return f + "_";
}  

bool save_script(const char * filename,const string & s){
  return write_file(filename_script(filename).c_str(),s.c_str());
}

int load_script(const char * filename,std::string & s){
  const char * ptr=read_file(filename_script(filename).c_str());
  if (!ptr) return 0;
  s=ptr;
  return 1;
}

size_t Bfile_ReadFile_OS4(const char * & hf_){
  const unsigned char * hf=(const unsigned char *)hf_;
  size_t n=(((((hf[0]<<8)+hf[1])<<8)+hf[2])<<8)+hf[3];
  hf_ += 4;
  return n;
}

size_t Bfile_ReadFile_OS2(const char * & hf_){
  const unsigned char * hf=(const unsigned char *)hf_;
  size_t n=(hf[0]<<8)+hf[1];
  hf_ += 2;
  return n;
}

void Bfile_ReadFile_OS(const char * &hf,char * dest,size_t len){
  memcpy(dest,hf,len);
  hf += len;
}

#define Current_Line (Start_Line + Cursor.y)
bool load_console_state_smem(const char * filename){
  //dbg_printf("load_console_state %s\n",filename);
  const char * hf=read_file(filename);
  //if (!hf){ console_output(filename,strlen(filename)); console_output(" not found\n",11); return true; }
  // if (strcmp(filename,"session.xw")){ console_output(hf,8); return true; }
  if (!hf) return false;
  string str;
  if (strncmp(hf,"#xwaspy\n",8)==0){
    hf+=8;
    const char * source=hf;
    for (;*source;source+=4){
      while (*source=='\n' || *source==' ' || (*source>='a' && *source<='~')){
        char c=*source;
        if (c=='}')
          c=')';
        if (c=='|')
          c=';';
        if (c=='~')
          c=':';
        str += c;
        ++source;
      }
      if (!*source)
        break;
      unsigned char a=source[0]-xwaspy_shift,b=source[1]-xwaspy_shift,c=source[2]-xwaspy_shift,d=source[3]-xwaspy_shift;
      str += char((a<<2)|(b>>4));
      str += char((b<<4)|(c>>2));
      str += char((c<<6)|d);
    }
    hf=str.c_str();
  }
  size_t L=Bfile_ReadFile_OS4(hf);
  char BUF[L+4];
  BUF[1]=BUF[0]='/'; // avoid trying python compat.
  BUF[2]='\n';
  Bfile_ReadFile_OS(hf,BUF+3,L);
  BUF[L+3]=0;
  load_khicas_vars(BUF);
  dconsole_mode=1;
  // read script
  L=Bfile_ReadFile_OS4(hf);
  if (L>0){
    char bufscript[L+1];
    Bfile_ReadFile_OS(hf,bufscript,L);
    bufscript[L]=0;
    if (edptr==0)
      edptr=new textArea;
    if (edptr){
      edptr->elements.clear();
      edptr->clipline=-1;
      edptr->filename=remove_path(remove_extension(filename))+".py";
      //cout << "script " << edptr->filename << endl;
      edptr->editable=true;
      edptr->changed=false;
      edptr->python=1;
      edptr->elements.clear();
      edptr->y=0;
      add(edptr,bufscript);
      edptr->line=0;
      //edptr->line=edptr->elements.size()-1;
      edptr->pos=0;
    }    
  }
  // read console state
  // insure parse messages are cleared
  Console_Init();
  Console_Clear_EditLine();
  for (int pos=0;;++pos){
    unsigned short int l,curs;
    unsigned char type,readonly;
    if ( (l=Bfile_ReadFile_OS2(hf))==0) break;
    curs=Bfile_ReadFile_OS2(hf);
    type = *hf; ++hf;
    readonly=*hf; ++hf;
    char buf[l+1];
    Bfile_ReadFile_OS(hf,buf,l);
    buf[l]=0;
    // ok line ready in buf
    while (Line[Current_Line].readonly)
      Console_MoveCursor(CURSOR_DOWN);
    Console_Input(buf);
    Console_NewLine(LINE_TYPE_INPUT, 1);
    if (Current_Line>0){
      line & cur=Line[Current_Line-1];
      cur.type=type;
      cur.readonly=readonly;
      cur.start_col+=curs;
    }
  }
  console_changed=0;
  Console_FMenu_Init(); // insure the menus are sync-ed
  return true;
}

void Bfile_WriteFile_OS(char * & buf,const void * ptr,size_t len){
  memcpy(buf,ptr,len);
  buf += len;
}
void Bfile_WriteFile_OS4(char * & buf,size_t n){
  buf[0]= n>>24;
  buf[1]= (n>>16) & 0xff;
  buf[2]= (n & 0xffff)>>8;
  buf[3]= n & 0xff;
  buf += 4;
}
void Bfile_WriteFile_OS2(char * & buf,unsigned short n){
  buf[0]= n>>8;
  buf[1]= n & 0xff;
  buf += 2;
}

void save_console_state_smem(const char * filename,bool xwaspy){
  console_changed=0;
  //dbg_printf("save_console_state %s\n",filename);
  string state(khicas_state());
  int statesize=state.size();
  //dbg_printf("save_console_state %s %i\n",filename,statesize);
  string script;
  if (edptr)
    script=merge_area(edptr->elements);
  int scriptsize=script.size();
  // save format: line_size (2), start_col(2), line_type (1), readonly (1), line
  int size=2*sizeof(int)+statesize+scriptsize;
  int start_row=0;//Last_Line-max_lines_saved; 
  if (start_row<0) start_row=0;
  for (int i=start_row;i<=Last_Line;++i){
    size += 2*sizeof(short)+2*sizeof(char)+strlen((const char *)Line[i].str);
  }
  char savebuf[size+4];
  char * hFile=savebuf;
  // save variables and modes
  Bfile_WriteFile_OS4(hFile, statesize);
  Bfile_WriteFile_OS(hFile, state.c_str(), statesize);
  // save script
  Bfile_WriteFile_OS4(hFile, scriptsize);
  Bfile_WriteFile_OS(hFile, script.c_str(), scriptsize);
  // save console state
  // save console state
  for (int i=start_row;i<=Last_Line;++i){
    line & cur=Line[i];
    unsigned short l=strlen((const char *)cur.str);
    Bfile_WriteFile_OS2(hFile, l);
    unsigned short s=cur.start_col;
    Bfile_WriteFile_OS2(hFile, s);
    unsigned char c=cur.type;
    Bfile_WriteFile_OS(hFile, &c, sizeof(c));
    c=1;//cur.readonly;
    Bfile_WriteFile_OS(hFile, &c, sizeof(c));
    unsigned char buf[l+1];
    buf[l]=0;
    strcpy((char *)buf,(const char*)cur.str); 
    unsigned char *ptr=buf,*strend=ptr+l;
    for (;ptr<strend;++ptr){
      if (*ptr==0x9c)
        *ptr='\n';
    }
    Bfile_WriteFile_OS(hFile, buf, l);
  }
  char BUF[2]={0,0};
  Bfile_WriteFile_OS(hFile, BUF, sizeof(BUF));
  int len=hFile-savebuf;
  //dbg_printf("save_session xwaspy=%i len=%i data=%x %x %x %x %x %x %x %x\n",xwaspy,len,savebuf[0]& 0xff,savebuf[1]& 0xff,savebuf[2]& 0xff,savebuf[3]& 0xff,savebuf[4]& 0xff,savebuf[5]& 0xff,savebuf[6]& 0xff,savebuf[7]& 0xff);
  if (
#ifdef XWASPY
      xwaspy && len<8192
#else
      0
#endif
      ){
    // save as an ascii file beginning with #xwaspy
    char * buf=savebuf;
    int newlen=4*(len+2)/3+10;
    char newbuf[newlen];
    strcpy(newbuf,"#xwaspy\n");
    hFile=newbuf+8;
    for (int i=0;i<len;i+=3,hFile+=4){
      // keep space \n and a..z chars
      char c;
      while (i<len && ((c=buf[i])==' ' || c=='\n' || c=='{' || c==')' || c==';' || c==':' || c=='\n' || (c>='a' && c<='z')) ){
        if (c==')')
          c='}';
        if (c==':')
          c='~';
        if (c==';')
          c='|';
        *hFile=c;
        ++hFile;
        ++i;
      }
      unsigned char a=buf[i],b=i+1<len?buf[i+1]:0,C=i+2<len?buf[i+2]:0;
      hFile[0]=xwaspy_shift+(a>>2);
      hFile[1]=xwaspy_shift+(((a&3)<<4)|(b>>4));
      hFile[2]=xwaspy_shift+(((b&0xf)<<2)|(C>>6));
      hFile[3]=xwaspy_shift+(C&0x3f);
    }
    //dbg_printf("save_session XWASPY %s\n",newbuf);
    //*hFile=0; ++hFile; 
    //*hFile=0; ++hFile;
    write_file(filename,newbuf,hFile-newbuf);
  }
  else {
    write_file(filename,savebuf,len);
  }
}

int get_filename(char * filename,const char * extension){
  handle_f5();
  string str;
#ifdef NSPIRE_NEWLIB
  int res=inputline((lang==1)?"esc ou chaine vide: annulation":"esc or empty string: cancel",(lang==1)?"Nom de fichier:":"Filename:",str,false);
#else
  int res=inputline((lang==1)?"EXIT ou chaine vide: annulation":"EXIT or empty string: cancel",(lang==1)?"Nom de fichier:":"Filename:",str,false);
#endif
  if (res==KEY_CTRL_EXIT || str.empty())
    return 0;
  strcpy(filename,str.c_str());
  int s=strlen(filename);
  if (strcmp(filename+s-3,extension))
    strcpy(filename+s,extension);
  // if file already exists, warn, otherwise create
  if (!file_exists(filename))
    return 1;
  if (confirm((lang==1)?"  Le fichier existe!":"  File exists!",
#ifdef NSPIRE_NEWLIB
              (lang==1)?"enter: ecraser, esc: annuler":"enter:overwrite, esc: cancel"
#else
              (lang==1)?"OK: ecraser,Back: annuler":"OK:overwrite, Back: cancel"
#endif
              )==KEY_CTRL_F1)
    return 1;
  return 0;
}


